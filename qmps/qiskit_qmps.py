from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer, execute
from qiskit.providers.aer import QasmSimulator, StatevectorSimulator, UnitarySimulator
from qiskit.quantum_info.operators import Operator
import numpy as np

from xmps.iMPS import iMPS, Map 
from xmps.spin import U4

from qmps.tools import unitary_to_tensor, environment_from_unitary, tensor_to_unitary, get_env_exact, get_env_exact_alternative
from qmps.time_evolve_tools import merge, put_env_on_left_site, put_env_on_right_site

def gate_to_operator(gate):
    """
    Returns a Qiskit Operator Object given a cirq Gate object
    """
    return Operator(cirq.unitary(gate))

def param_unitary(params, gate, inverse = False):
    """
    Build a parameterized unitary Operator from a set of parameters with a parameterization determined by gate.
    """
    return gate_to_operator(gate(params))

def partial_trace(ρ, n_spins, spins_keep):
    '''
    Perform a partial trace on a density matrix ρ. The size of ρ is 2^(n_spins) x 2^(n_spins), and the size of the space that is not traced out is 2^(len(spins_keep)) x 2^(len(spins_keep)). 
    
    This is needed because qiskit has no inbuilt ability to specify the reduced density matrices of a subset of the simulated qubits.
    '''
    reshaped = ρ.reshape(2*n_spins*[2])
    ket_index = [i for i in reversed(range(n_spins))]
    bra_index = [i + n_spins if i in spins_keep else i for i in reversed(range(n_spins))]
    
    einsum_index = ket_index + bra_index

    reduced = np.einsum(reshaped, einsum_index)

    output_dim = 2*len(spins_keep)
    output = reduced.reshape(output_dim, output_dim)
    return output

def represent_full_cost_function(params, U, gate):
    '''
    Cost function for variationally finding the environment of an iMPS with a quantum circuit. Requires full tomography of the reduced density matrices that are being evaluated.
    '''
    simulator = Aer.get_backend('statevector_simulator')
    target_environment = Operator(gate(params))
    
    circ_ρσ = QuantumCircuit(5)
    
    circ_ρσ.append(target_environment, [2,1])
    circ_ρσ.append(U, [1,0])
    circ_ρσ.append(target_environment, [4,3])
    
    result = execute(circ_ρσ, simulator).result()
    statevector = result.get_statevector(circ_ρσ)
    ρ = np.outer(statevector, statevector.conj())
    
    ρ_1 = partial_trace(ρ, 5, [0])
    ρ_2 = partial_trace(ρ, 5, [3])
    
    return np.linalg.norm(ρ_1-ρ_2)

def represent_sampled_circuit(params, U, shots, gate):
    '''
    Cost function for variationally finding the environment of an iMPS with a quantum circuit, without requiring the full reduced density matrix to be specified. Trace distance = Tr[|(ρ-σ)^2|] is used instead. 
    
    All estimated reduced density matrices are returned for the sake of debugging, see represent_sampled_cost_function() for the funciton to be used by optimizers. 
    '''
    simulator = Aer.get_backend('qasm_simulator')
    target_environment = Operator(gate(params))

    circ_ρσ = QuantumCircuit(5, 2)
    circ_ρρ = QuantumCircuit(4, 2)
    circ_σσ = QuantumCircuit(6, 2)
    
    circ_ρσ.append(target_environment, [2,1])
    circ_ρσ.append(U, [1,0])
    circ_ρσ.append(target_environment, [4,3])
    circ_ρσ.cx(0,3)
    circ_ρσ.h(0)
    circ_ρσ.measure([0, 3], [0,1])
    
    circ_ρρ.append(target_environment, [1,0])
    circ_ρρ.append(target_environment, [3,2])
    circ_ρρ.cx(0,2)
    circ_ρρ.h(0)
    circ_ρρ.measure([0,2], [0,1])

    circ_σσ.append(target_environment, [2,1])
    circ_σσ.append(U, [1,0])
    circ_σσ.append(target_environment, [5,4])
    circ_σσ.append(U, [4,3])
    circ_σσ.cx(0,3)
    circ_σσ.h(0)
    circ_σσ.measure([0,3], [0,1])

    result_ρσ = execute(circ_ρσ, simulator, shots=shots).result()
    counts_ρσ = result_ρσ.get_counts(circ_ρσ)
    
    result_ρρ = execute(circ_ρρ, simulator, shots=shots).result()
    counts_ρρ = result_ρρ.get_counts(circ_ρρ)
    
    result_σσ = execute(circ_σσ, simulator, shots=shots).result()
    counts_σσ = result_σσ.get_counts(circ_σσ)
    
    # If no 11s are measured then the test has failed 0 times so (1 - Tr[ρσ]) / 2 = 0 i.e. Tr[ρσ] = 1
    
    try:
        _ = counts_ρσ['11']
    except:
        counts_ρσ['11'] = 0
    
    try:
        _ = counts_σσ['11']
    except:
        counts_σσ['11'] = 0
    
    try:
        _ = counts_ρρ['11']
    except:
        counts_ρρ['11'] = 0
    
    ρρ = 1 - 2*(counts_ρρ['11']/shots)  # Trace [ρ^2]
    σσ = 1 - 2*(counts_σσ['11']/shots)  # Trace [σ^2]
    ρσ = 1 - 2*(counts_ρσ['11']/shots)  # Trace [ρσ]
    
    score = ρρ + σσ - 2 * ρσ  # Trace [|(ρ - σ)|^2]

    return [score, ρσ, ρρ, σσ]

def represent_sampled_cost_function(params, U):
    """
    Cost function that uses the circuit generated by represent_sampled_circuit() as a target to minimize. 
    """
    scores = represent_cost_function_full_return(params, U)
    return scores[0]

def simulate_state(U, V):
    """
    Function to return the state of the qmps in canonical form once of a given state and environment. Only works for 2 site Hamiltonians.
    """
    simulator = Aer.get_backend('statevector_simulator')
    
    c = QuantumCircuit(4)
    
    c.append(V, [3,2])
    c.append(U, [2,1])
    c.append(U, [1,0])
    
    result = execute(c, simulator).result()
    ψ = result.get_statevector(c)
    return ψ

def energy_cost_fun(params, H, gate):
    """
    energy minimized when looking for the ground state of a 2-site hamiltonian H.
    """
    U = gate(params)
    try:
        V = get_env_exact(U)
    except:
        V = get_env_exact_alternative(U)
    
    ψ = simulate_state(Operator(U), Operator(V))
    
    H = np.kron(np.kron(np.eye(2), H), np.eye(2))
    E = ψ.conj().T @ H @ ψ
    return E.real

def time_evolve_sim_state(params, U, W):
    """
    Circuit which returns the overlap between 2 MPS states, defined by the unitaries U_ = U4(params) & U = tensor_to_unitary(A). The full wavefunction is returns for debugging purposes.
    """
    
    circ = QuantumCircuit(6,6)
    
    U_ = self.gate(params)
    A = unitary_to_tensor(cirq.unitary(U))
    A_ = unitary_to_tensor(cirq.unitary(U_))
    
    _, r = Map(A, A_).right_fixed_point()
    
    R = Operator(put_env_on_left_site(r))
    L = Operator(put_env_on_right_site(r.conj().T))
    
    circ.h(3)
    circ.cx(3,4)
    circ.unitary(U, [3,2])
    circ.unitary(U, [2,1])
    circ.unitary(L, [1,0])
    circ.unitary(R, [5,4])
    circ.unitary(H, [3,2])
    circ.unitary(target_u, [2,1])
    circ.unitary(target_u, [3,2])
    circ.cx(3,4)
    circ.h(3)
    
    result = execute(circ, simulator).result()
    ψ = result.get_statevector(circ)
    
    return ψ

def time_evolve_cost_fun(params, U, W):
    """
    objective funciton that takes the probabiltiy of the all-zeros state from the wavefunction returns by time_evolve_sim_state(). This value is multiplied by 2 for normalization purposes.
    """
    return np.abs(time_evolve_sim_state(params, U, Operator(W))[0])*2